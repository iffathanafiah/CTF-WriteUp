import math
#from Crypto.Util.number import *
from sympy import gcd, mod_inverse
from random import randint

# Given e
e = 1367 # 0x557 , I just want to clearly see the value of e

# CPA attack (Chosen Plaintext Attack)
# plaintext -> encryption oracle -> ciphertext
# Choose 2 plaintext to get 2 ciphertext
m1 = 33 # ! in ascii
m2 = 66 # B in ascii
c1 = 22030133242964166797730708399012338405030357458836956726521976575093956342902119470931290160562918845813372700425433128851475598318306658519990392950878845077826580525851525902382979061892273664730626129946478981952975734562620821208461048927036886634837450964800769503388981651317050467979867043276984586829973958186029003436247224212658185333250214265157716380849337111562522601118392807630843887330641694836303748958646620436959873161046768045240291800382174156458035007615487324085511299326882686528541656253835578644908756486389260355046118069573515942618891256898849492876857375395387585311660893585126794156478
c2 = 12125510848421010634685474605497621838246320989420616252395436943275482613518537810244762155848369807563757698209227274565057229836175624930070421039398312677749457395103691121235464503455577527117741534819134576696880137416410959164135750550603137674972849985414979222820611647962987865546662307106882942834212284977420466458628506827082544548161330874368002994703927691541544590636134343764592901105793539942797660203319170196782125834477234832236118586333694720187798416350229834042597356461397833123186663868912932952478746561546820122144634873317619853006850286305328887429517333889433547456974568313550453506366

# Based on https://github.com/ashutosh1206/Crypton/blob/master/RSA-encryption/Attack-Retrieve-Modulus/README.md
# If value of e is known, then we can compute n = gcd(c1-m1^e,c2-m2^e)
# Compute n = gcd(c1-m1^e,c2-m2^e)
first = c1 - pow(m1, e)
second = c2 - pow(m2, e)
n = math.gcd(first, second)
print("N: ",n)

# CCA attack (Chosen Ciphertext Attack)
# ciphertext -> decryption oracle -> plaintext
# "Textbook RSA" is vulnerable to CCA attack
# Based on CCA Attack, we need to multiply the encrypted_flag with a random number r, then encrypt it to produce C' = C * r^e mod n
# C' will be send to the decryption oracle to get M' = C' ^ d mod n
# which M' = (C * r^e) ^ d mod n = C^d * r^ed mod n
# Based on the property of RSA, e*d = 1 mod phi(n), So e*d must equal to 1
# Basic RSA, M = C^d mod n
# M' = M * r mod n
# M = M' * r^-1 mod n

# Paste the encrypted_flag here
encrypted_flag = 9434091013498189979174836922251415147092994317151059292190040753499067114680755388570202672444847948256410189179591191312604589395450373323736809446074531362539020471110556511162472238081571561743592914320090377269394822360158216520989999203414194575539985983169843117035216482028155787105799476846938697345054216273540077802121976251681997418384713279707764486968127541709369871609383106241236227624125200729719485090082010719208781250892941169876613956129642710738360872520072445811212378161516799718591652850645208894168036626087630943386180580561180508509920017077848241742526749102016878289482128906058055058390

# Function to generate random `r` value from n
def generate_random_r(n):
    while True:
        r = randint(2, n - 1)  # Random integer in range [2, n-1]
        if gcd(r, n) == 1:  # Ensure `r` is coprime with `n`
            return r

# Generate random `r` value
r = generate_random_r(n)
print("\nRandom r value:", r)

# Due to the manual process that I used, we need to make sure that the r is the same throughout the process of encrypting and decrypting
# Different n, different r
# Before this I get this r and use it to get the new encrypted flag
r = 353361751467373808963547164151213841537815021539509584366332032099756449197542277630851571695966659068895571245271696028132824497704197708519469154737748711595581080651178607085428141706294637804585990522305917517636228447680681640497060917704109534616507780674881997854027848377772115315868125751234718426351673948674405490817719659925936586976038370309364457155648487022020471227395711425177381103797615650477440875793909035090720808347416832655529020883122674653960681794620217913219348752039939321587512277852228618336796968274257617349831280841733530852856172212792935148116764327465432524379301072198291640773

# C' = C * r^e mod n
new_encryptedflag= (encrypted_flag*pow(r, e)) % n

# Send the new_encryptedflag to the decryption oracle
print("\nNew Encypted Flag (C'): ", new_encryptedflag)

# Receive M' from the decryption oracle
# M' = M * r
m_prime = 15937585863644726557279437384137232243210865837725387628595068681884619726105021399311715128422430650551422880337525017496385627885613730540850481415548757120183880649723578105632663877832383886787796340880822775876077236928034844216869466557156432047291069411713379302474883799841276244244233859610205735135902395295308897956560304863397181446639418735707766802827435742032362170955543671150424530397435577525426407127101341610566307918232872711111878248052952678495059010827745018079837500751050061803420855279204266100951792607180252602896100008517843721890788225101029765099138230098561232375796899337140243476730

# M = M' * r^-1 mod n
encoded_flag = (m_prime * mod_inverse(r,n)) % n

print("\nEncoded Flag: ", encoded_flag)
# Encoded Flag: 15201892040119364990483834841798236623598320919650209676780920528532794290727504714893714557

print("\nDecoded Flag:",long_to_bytes(encoded_flag).decode())
# Get the Decoded Flag: wgmy{ce7a475ff0e122e6ac34c3765449f71d}
